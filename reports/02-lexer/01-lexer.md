# –õ–µ–∫—Å–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä
–°–∏–º–≤–æ–ª—ã, —Å—á–∏—Ç–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞, –ø–æ—Å—Ç—É–ø–∞—é—Ç –≤ –ª–µ–∫—Å–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä.
–ó–∞–¥–∞—á–∞ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ - –∏–∑ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ —Å–æ–±—Ä–∞—Ç—å –ª–µ–∫—Å–µ–º—ã:
- –õ–∏—Ç–µ—Ä–∞–ª—ã (—á–∏—Å–ª–∞, —Å—Ç—Ä–æ–∫–∏),
- –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
- –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã
- –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã

–õ–µ–∫—Å–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –¥–æ–ª–∂–µ–Ω –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–∏–º–≤–æ–ª–æ–≤,
–≤—ã–¥–µ–ª—è—è –∏–∑ –Ω–µ—ë –ª–µ–∫—Å–µ–º—ã (—Ç–æ–∫–µ–Ω—ã) –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è –ª–µ–∫—Å–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏.

–õ–µ–∫—Å–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –æ–±—Ö–æ–¥–∞
–≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤, –∫–∞–∫ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, —Ç–æ –µ—Å—Ç—å —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å
–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞.

## –•—Ä–∞–Ω–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤
–î–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–æ–≤ –≤–≤–µ–¥—ë–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É `Token`, –∞ —Ç–∞–∫–∂–µ –ø–µ—Ä–µ—á–∏—Å–ª–∏–º—ã–π
—Ç–∏–ø `TokenType`:
```rust
pub struct Token {
    pub(crate) token: TokenType,
    pub(crate) pos: (usize, usize),
}

pub enum TokenType {
    Integer(i32),
    Identifier(String),
    StringLiteral(String),
    Real(f32),
    ProgramKeyword,
    VarKeyword,
    BeginKeyword,
    ...
}

```
Enum –≤ Rust –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–º. –í–æ—Å–ø–æ–ª—å–∑—É–µ–º—Å—è —ç—Ç–∏–º, —á—Ç–æ–±—ã —Ö—Ä–∞–Ω–∏—Ç—å
–∏–∑–≤–ª–µ—á—ë–Ω–Ω—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã –≤–º–µ—Å—Ç–µ —Å —Ç–∏–ø–æ–º —Ç–æ–∫–µ–Ω–∞. –ß–∞—Å—Ç—å —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–µ—Ä–µ—á–∏—Å–ª–∏–º–æ–≥–æ —Ç–∏–ø–∞ –∏–º–µ—é—Ç –∫–æ—Ä—Ç–µ–∂–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É ‚Äí
–∞—Ä–≥—É–º–µ–Ω—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è. –ù–∞–ø—Ä–∏–º–µ—Ä, —á–∏—Å–ª–æ–≤—ã–µ –∏–ª–∏ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ
–ª–∏—Ç–µ—Ä–∞–ª—ã. –î–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ç–∞–∫–∂–µ –≤–≤–µ–¥—ë–Ω –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω
EOF ‚Äí —Å–∏–º–≤–æ–ª –∫–æ–Ω—Ü–∞ –ø–æ—Ç–æ–∫–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –ª–æ–≥–∏–∫–µ —Ä–∞–±–æ—Ç—ã
–∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞.

–ü–æ–º–∏–º–æ —Ç–∏–ø–∞ —Ç–æ–∫–µ–Ω–∞ —Ç–∞–∫–∂–µ —Ö—Ä–∞–Ω–∏–º –µ–≥–æ –ø–æ–∑–∏—Ü–∏—é –≤ —Ç–µ–∫—Å—Ç–µ ‚Äí —ç—Ç–æ –ø—Ä–∏–≥–æ–¥–∏—Ç—Å—è
–Ω–∞ –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö —ç—Ç–∞–ø–∞—Ö –∞–Ω–∞–ª–∏–∑–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫.

## –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ª–µ–∫—Å–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞
–î–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –ª–µ–∫—Å–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–æ–∫ —Å–æ–∑–¥–∞–Ω–∞ –æ—Ç–¥–µ–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ `CompilerError` –∏ enum `ErrorType`:
```rust
pub enum ErrorType {
    Lexical,
    Syntax,
    Semantic,
}

pub struct CompilerError {
    description: String,
    pos: (usize, usize),
    err_type: ErrorType,
}

impl CompilerError {
    pub fn new(description: String, pos: (usize, usize), err_type: ErrorType) -> Self {
        Self {
            description,
            pos,
            err_type,
        }
    }
    ...
}
```
–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –æ—à–∏–±–∫–∏, –µ—ë —Ç–∏–ø, –∞ —Ç–∞–∫–∂–µ –ø–æ–∑–∏—Ü–∏—é –≤ —Ñ–∞–π–ª–µ, –≥–¥–µ –æ–Ω–∞ –ø—Ä–æ–∏–∑–æ—à–ª–∞.

–õ–µ–∫—Å–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–¥–∞–Ω –≤ –≤–∏–¥–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã:
```rust
pub struct Lexer {
    chars: CharReader,
}


impl Lexer {
    pub fn new(chars: CharReader) -> Self {
        Self { chars }
    }
    ‚Ä¶
}

```

–î–ª—è –æ–±—Ö–æ–¥–∞ —Ç–æ–∫–µ–Ω–æ–≤ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω trait `Iterator`:
```rust
impl Iterator for Lexer {
    type Item = Result<Token, LexicalError>;

    fn next(&mut self) -> Option<Self::Item> {
        self.skip_ws();

        let token = match self.chars.by_ref().current_char() {
            Some(ch) => match ch {
                '0'..='9' => self.number(),
                '+' | '-' | '*' | ':' => self.operator(),
                _ if ch.is_alphanumeric() => self.maybe_keyword(),
                _ => self.symbol(),
            },
            None => Ok(Token::EOF),
        };

        match token {
            Ok(Token::EOF) => None,
            _ => Some(token),
        }
    }
}
```

–í –º–µ—Ç–æ–¥–µ `next()` –º—ã –æ–±—Ö–æ–¥–∏–º –ø–æ—Å–∏–º–≤–æ–ª—å–Ω–æ –∏—Å—Ö–æ–¥–Ω—ã–π —Ñ–∞–π–ª –ø—Ä–∏ –ø–æ–º–æ—â–∏
`CharReader`, –∫–æ—Ç–æ—Ä—ã–π —Ç–æ–∂–µ –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —Å—á–∏—Ç—ã–≤–∞–µ—Ç —Å–∞–º –∏—Å—Ö–æ–¥–Ω—ã–π —Ñ–∞–π–ª.
–í –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∏–º–≤–æ–ª–∞ –∑–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ª–µ–∫—Å–µ–º—ã –∏–ª–∏ –≥—Ä—É–ø–ø—ã –ª–µ–∫—Å–µ–º.

–û–±—Ä–∞–±–æ—Ç–∫–∞ —á–∏—Å–µ–ª –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ø—Ä–∏ –≤—ã—è–≤–ª–µ–Ω–∏–∏ —Ü–∏—Ñ—Ä—ã –≤ –Ω–∞—á–∞–ª–µ –æ—á–µ—Ä–µ–¥–Ω–æ–π –≤—ã–¥–µ–ª—è–µ–º–æ–π –ª–µ–∫—Å–µ–º—ã.
–ï—Å–ª–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –±—ã–ª–∞ –Ω–∞–π–¥–µ–Ω–∞ —Ç–æ—á–∫–∞, —Ç–æ –ø—ã—Ç–∞–µ–º—Å—è –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å
–∫–∞–∫ –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ, –∏–Ω–∞—á–µ - –∫–∞–∫ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ. –ï—Å–ª–∏ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ
–≤–æ–∑–Ω–∏–∫–ª–∞ –æ—à–∏–±–∫–∞, —Ç–æ —Å–æ–∑–¥–∞—ë—Ç—Å—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∞—è –ª–µ–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∏
–ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –∫–∞–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏. –ï—Å–ª–∏ —á–∏—Å–ª–æ–≤–æ–π –ª–∏—Ç–µ—Ä–∞–ª –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω,
—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–∫–µ–Ω.

–û–±—Ä–∞–±–æ—Ç–∫–∞ —á–∏—Å–µ–ª:
```rust
impl Lexer {
    ‚Ä¶
    fn number(&mut self) -> Result<Token, LexicalError> {
        let mut num = String::new();
        let mut is_real = false;

        loop {
            match self.chars.by_ref().current_char() {
                Some(ch) if ch.is_digit(10) => num.push(ch),
                Some(ch) if ch == '.' => {
                    num.push(ch);
                    is_real = true;
                }
                Some(ch) if ch.is_whitespace() => break,
                Some(ch) if ch.is_alphanumeric() => {
                    // Consume everything until whitespace or EOF
                    num.push(ch);

                    while let Some(ch) = self.chars.next() {
                        if ch.is_whitespace() {
                            break;
                        } else {
                            num.push(ch);
                        }

                        break;
                    }
                }
                _ => break,
            }

            self.chars.by_ref().next();
        }

        if is_real {
            let parsed = num.parse::<f32>();

            match parsed {
                Ok(f) => Ok(Token::Real(f)),
                _ => {
                    let pos = self.chars.position();
                    Err(LexicalError::new(
                        String::from(format!("Invalid real literal {}", num)),
                        pos.0,
                        pos.1,
                    ))
                }
            }
        } else {
            let parsed = num.parse::<i32>();

            match parsed {
                Ok(i) => Ok(Token::Integer(i)),
                _ => {
                    let pos = self.chars.position();

                    Err(LexicalError::new(
                        String::from(format!("Invalid int literal {}", num)),
                        pos.0,
                        pos.1,
                    ))
                }
            }
        }
    }
    ‚Ä¶
}
```

–ü—Ä–∏–º–µ—Ä - –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤ –∏ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤:
```rust
fn maybe_keyword(&mut self) -> Result<Token, LexicalError> {
    if self.chars.by_ref().current_char().is_none() {
        Ok(Token::EOF)
    } else {
        let mut s = String::new();
        s.push(self.chars.by_ref().current_char().unwrap());

        loop {
            match self.chars.next() {
                Some(ch) if ch.is_alphanumeric() => s.push(ch),
                _ => break,
            }
        }

        match s.to_lowercase().as_str() {
            "div" => Ok(Token::DivOp),
            "mod" => Ok(Token::ModOp),
            "program" => Ok(Token::ProgramKeyword),
            "begin" => Ok(Token::BeginKeyword),
            "end" => Ok(Token::EndKeyword),
            "integer" => Ok(Token::IntegerKeyword),
            "real" => Ok(Token::RealKeyword),
            "var" => Ok(Token::VarKeyword),
            _ => Ok(Token::Identifier(s)),
        }
    }
}
```

## –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
–ü—Ä–æ–≤–µ—Ä–∏–º –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–º —Ç–µ–∫—Å—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã:
```Pascal
program HelloWorld;
var
    x, z, y : integer;
    b : boolean;
    a, b: myType;
begin
    a := b + 10;

    if 10 > 9 then
        x := 42;

    if 6 > 3 then
        b := true;
    else
        if 3 < 6 then
            b := false;
    x := 25;


    while x + 10 do
        x := x - 1;

    x := 5 * (12 * y + 1);
    x := 25 + x - 131.25
        - 333 + z div 3 mod 2
        mood 4;
end.
```

–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–±–æ—Ç—ã:
![–¢–µ—Å—Ç](./imgs/test.png)

–î–æ–±–∞–≤–∏–º –≤ —Ç–µ–∫—Å—Ç emoji üçî –∏ —Å–∏–º–≤–æ–ª —Å –¥–∏–∞–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–º –∑–Ω–∞–∫–æ–º:
![–¢–µ—Å—Ç —Å –æ—à–∏–±–∫–∞–º–∏](./imgs/errors.png)

–ö–∞–∫ –≤–∏–¥–∏–º, emoji –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è, —Ç–∞–∫–∂–µ —É –Ω–∞—Å –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç
–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ª–∏—Ç–µ—Ä–∞–ª (–∏–ª–∏ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä, –Ω–∞—á–∏–Ω–∞—é—â–∏–π—Å—è —Å —Ü–∏—Ñ—Ä).